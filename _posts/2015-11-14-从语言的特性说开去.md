---
layout: post
title:  "从语言的特性说开去"
modified:   2015-11-15
tags: [ios, 技术, android]
comments: true
---

这篇文章写起来挺艰难的。因为网上很少有人提到过这种对于android和ios的横向比较。因缘际会之下博主同时接触了这两种语言这两个平台。也把我的一些体会分享给大家。

### 语言的特性  

#### 1. 划分
　　首先，OC是编译型语言，Java是混合型语言；OC是动态语言，Java是静态语言。它们又都是面向对象的静态类型语言。前者的区别造成了它们在代码形式风格上的诸多不同；后者又使它们在写法上诸多类似。
这里补充一点：动态类型语言和动态语言是两个概念。动态类型语言指的是运行期间才去做数据类型检查的语言，类似一些脚本语言，重点是数据类型。而动态语言指的是运行期间可以改变代码结构的语言，比如Object-C、C#、JavaScript、PHP；反之则如Java、C、C++。所以在这一点上，Java和OC显露出了分歧。  

Java有虚拟机JVM的概念。

关于Java运行时的逻辑图：

![image]({{ site.url }}/img/language_java.jpg)

注：Java先生成字节码，再在Java虚拟机中解释执行。所以是混合型语言。

| 级别| 回收时机  | 用途                                | 生存时间         |
|:---:| :--------  :------------------------          |:--------------- |
| 强 | 从来不会   | 对象的一般状态                       | JVM停止运行时终止 |
| 软 | 内存不足时 | 对象的二级高速缓存                    | 内存不足时终止    |
| 弱 | 垃圾回收时 | 对象的一级高速缓存                    | gc运行后终止     |
| 虚 | 垃圾回收时 | 联合ReferenceQueue跟踪垃圾回收器的活动 |gc运行后终止      |

#### 2. 继承vs组合

　　<strong>*oc喜欢用组合来组织类与类之间的关系（比如category）*  
　　*java却喜欢用面向对象，继承的方式来衍生出更多的类。*</strong>

假如你想在全局的activity里做点什么，你会多重继承。拿百姓网主站app举例：  
`BXMainActivity→ BaixingBaseActivity→BaseActivity`  
这么一个继承关系。

<!--more-->

　　假如你想在所有的Fragment中定制UI特有的表现形式，比如全局的底部菜单栏。Java会定义一个BaseFragment来做这件事，以后其他多个Fragment都需要做的事情也会放在Base类里。每当新写一个fragment，都需要先继承base类。这样会导致继承关系复杂，并且最后把很多不同的事全扔到Base类里做。Base类里的代码变得不可看。

并且，一个新来的同学可能不知道它们的继承关系；一个基于敏捷开发的小demo想要合进来也变得狠困难。  

　　OC有一种天然的组合方式叫category。 如果你想实现上述的功能，只需对controller派生一个UIViewController+BottomMenu，在需要的页面去import它。通过这样的方式可以将不同功能打散到特定的category里。  
`UIViewController.m, UIViewController+BottomMenu.m` 这么个关系。  

　　这里对仅了解Java的朋友说明一点：OC的category不是只能扩展自定义的类，而是可以改变cocoa底层的框架类，甚至是更底层的OC类（相当于android类和Java类）。 
OC之所以能做到这一点，是因为它在编译阶段将include的头文件代码写入了进来，而C系列的语言是动态不定长的，既有类里的方法可以被改变；而Java为了安全、封闭等考虑，不让开发者写完一个类再去修改里面的内容。


Java想要做到动态改原生Activity，只能使用一种Hack的方式，即反射。  

#### 3. runtime VS reflection

想要要更深入地理解这种区别，不得不提到runtime和reflection。  
iOS中的运行时编程，类似Java的反射。  
Java是一门静态语言，类和方法都有严格的public, private之分。而反射机制却可以实现动态性，获取类的私有方法等。

##### 　　3.1 相同点

　　都可以实现的功能：获取类信息、属性设置获取、类的动态加载、方法的动态调用等。
	
　　**ios中相关方法使用：**
	
　　类的动态加载：`NSClassFromString(@“className”)`
	
　　方法的动态调用：`NSSelectorFromString(@“doSomethingMethod”)`

　　……

　　**Java反射API**的第一个主要作用是获取程序在运行时刻的内部结构。

　　通过`getConstructor、getField和getMethod`这三个方法可以获取到`java.lang.Class类` 的对象中的构造方法、域和方法。（注：`java.lang.Class类`是所有Java类的父类）

　　具体参见：<a href='http://www.bingjie.me/2015/11/03/OC%E4%B8%AD%E7%9A%84runtime%E4%B8%8EJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94.html'>OC中的runtime与Java反射机制对比</a>

##### 　　3.2 不同点
 
　　OC能动态得给class添加类和方法，Java则不行。例如
　　{% highlight Objective-C %}
import<objc/runtime.h>
Class newClass = objc_allocateClassPair([NSError class], "RuntimeErrorSubclass", 0);
class_addMethod(newClass, @selector(report), (IMP)ReportFunction, "v@:"){% endhighlight %}  

#### 4. 启动原理
另外，Java有虚拟机JVM的概念。

关于Java运行时的逻辑图：

![image]({{ site.url }}/img/language_java.jpg)

而编译型的OC则相对简单：  
__Objective-C → Compiler-gcc → .o文件 → linker装载器 → executable可执行文件__  
其中，编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。

### 平台的特性

#### ARC与GC的异同

1. GC是什么？
GC，garbage collection。
Java由GC来负责回收内存。

2. ARC是什么？
ARC是一种OC对象的自动管理机制，由LLVM编译器来保证（这件事情在预编译的过程中完成最好不过）。编译器在编译期间，动态地帮你添加retain/release/autorelease。同时，还引入了新的运行时特性：弱指针，性能优化等。

3. difference
Java中的GC与OC中的ARC都有计数器的概念。
其实，ARC借鉴了现代语言中的引用计数。当时看的时候在想Java有非常完善的引用计数机制。但ARC又不是GC，它不扫描堆、不暂停进程运行，没有不确定的内存释放。所以其实你可以理解ARC是狠轻的对象管理，帮你添加了一些代码，是编译器提供的机制，而不是GC这种复杂的运行时机制。

4. 我们可以怎样在android中利用GC机制？
首先，不同厂商的JVM对于GC的调用策略不同，但我们在应用层不需要关心这些。我们只需要知道，GC过程与对象的引用类型是严重相关的，我们来看看Java对引用的分类Strong reference, SoftReference, WeakReference, PhatomReference。如下图：

![image]({{ site.url }}/img/language_gc.jpg)

对于这一点，常体现在对于Bitmap的引用上。下面再展开阐述。这就引出了一个非常重要的话题：性能优化。

三、关于性能优化：
android面临的内存问题要比ios的严峻很多。我们来看一下对比：  
iOS8/iPhone6/646MB  
Android 4.1/Mi2/96MB  
WOW!  
而随着android手机越做越好，努力地去满足消费市场：屏幕越做越大，内存等硬件参数也越来越好看。这个问题有没有好转呢？让我们来看下面这幅图：

![image]({{ site.url }}/img/language_cache.jpg)


尽管苹果的消费者对于摄像头、分辨率的呼声很高。苹果并没有一味地去迎合消费市场。
言归正传，回到这样一个场景：假如我们有很多个经常需要用到的bitmap展示，最佳实践应该是怎样的？怎样利用好Java的GC原理?

如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：

首先定义一个HashMap，保存软引用对象。  
1.private Map<String, SoftReference<Bitmap>> imageCache = new HashMap<String, SoftReference<Bitmap>>();

再来定义一个方法，保存Bitmap的软引用到HashMap。 

![image]({{ site.url }}/img/language_bitmap.jpg) 

使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。

如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。

另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。

总而言之，__堆内存中的长生命周期的对象持有短生命周期对象的强/软引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的根本原因。__

下面是进程回收优先级图：

![image]({{ site.url }}/img/language_process.jpg)

垃圾回收的四个触发时机:
1、当一个进程死亡时
2、当启动指定的activity失败时
3、在更新adj值时
4、处理完当前所有广播时

Java编程建议

根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议：

1）最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null，这样可以加速GC的工作。
2）尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。
3）如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.
4）注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。
5）当程序有一定的等待时间，程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。

trim Memory的逻辑主要是根据进程内存回收的级别调用handleTrimMemory进行内存回收工作

垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收Young中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。

### 安卓和iOS不同的优化策略

#### 工具

就我个人的经验来说，做android程序员要比做ios程序员苦逼许多。这种苦逼首先体现在各种工具的使用上。android往往让你去系统改些配置文件，比如配java环境变量，android环境变量，adb环境变量etc。。。甚至还有一个官方发布的dmtracedump的工具，前几年都不能用。今年能用了，但是想用之前你得装另外一个工具：Graphviz Dot。即使装完了，用起来也非常不方便，使用方法详见：http://www.xuebuyuan.com/908393.html
这个等下会提到。
就算你往上打怪，把这些变量都配完了工具能用了，这个工具也起码要比ios的慢个几倍。等待让人狠烦躁。

但是iOS就不需要了，没见过哪个工具不可以直接使用，或者不能使用的。苹果有一个非常强大的性能监控工具，instruments。它是苹果全平台的广泛数据收集器。你可以利用它分析所有前面在android部分提到的不同模块不同维度。

我们首先来说一下android平台下的工具：
写不下了，详见另一篇笔记：
《开发Android必知的工具》

等下详细讲解下android中一个非常强大又经常被我们忽略的工具，TraceView。

好了，android有那么多的工具，苹果有些什么呢？
po一张图：

之所以称这个工具为苹果的工具而不是iOS的工具，是因为它是全平台的。
这是我运行聚车商在instruments里截的图：

要注意的是最好在真机上运行，模拟器上很多格子都没有。

#### 关于android的TraceView:
详见另一篇笔记：《关于android的TraceView》

（注：dmtracedump用来将程序运行期间整个调用过程和时间结合分析，以函数调用图的形式表现出来。并没有traceview强大，可以生成直观的树形图）
po一张图感受下：

其他的区别：

#### 支持的图片格式

详见：http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/

#### 支持的语音格式
aac: 都支持
amr: android支持，iOS不支持。

我们可以从iOS身上学到什么：
iOS引入一种"Watch Dog"[看门狗]机制.不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程.
为了防止一个应用占用过多的系统资源，开发iOS的苹果工程师门设计了一个“看门狗”的机制。在不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程。开发者们在crashlog里面，会看到诸如0x8badf00d这样的错误代码。
android中没有，不过我们可以自己构造一个看门狗机制。具体可以讨论下。

https://www.udacity.com/course/android-performance--ud825