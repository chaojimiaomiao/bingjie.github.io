---
layout: post
title:  "OC中aspect切面编程"
modified:   2015-11-05 15:07:19
tags: [ios, 技术]
comments: true
---
每一个技术变化都要从PM的一个需求讲起。对于一个ios应用来说，当第一版的功能完成得差不多以后，我们就必不可少地要为应用中用户的各种行为记录log或track。市面上有不少的应用统计第三方库，类似：umeng,GA,mixpannel & etc.. 假设产品有这么个需求，当用户在详情页点击购买按钮时，记录一下事件。我们实现起来大概会是这样的：

{% highlight Objective-C %}
// DetailViewController.m

- (void)onBuyButtonPressed:(UIButton *)button
{
    // do some stuff, maybe send a request to server
    [XXXAnalytics event:kSomeEventYouDefined];
} {% endhighlight %}

这个需求就这样轻松搞定了。可是PM又说：我要的不止是点击购买按钮，我还需要点击拨打电话按钮，发送短信按钮，私聊按钮，发布按钮，设置按钮，求购按钮……

一开始，你或许会尝试在PM所说的每一个buttonPress方法中加上`[XXXAnalytics event:kSomeEventYouDefined];`这行代码。这时候一部分优秀的程序员已经开始抓狂了，因为到处散落着相似的代码。另一部分或许会有些不安，但还是勉强接受了这种写法。

突然有一天，PM一拍脑袋说：我们这个设计已经落伍了，这个版本我们要给所有的UI换上新衣服。另外，以前记的许多log都不需要了，并且增加了新的log。

苦逼的程序员这下崩溃了。他发现不仅要在新的UI中加入track，还需要找到并删除旧的track。然而旧的track散落在程序的各个角落，他不得不ctrl+F一个个搜到再看下是否有用。这种情况下，__漏删与少加很可能发生__。

为什么会产生这样的情况，还是最初的设计出了问题。如果一开始我们能找到一种合适的架构，使得这些log在同一处被记上，就不会发生这样的情况。此时我们引入__Aspect Oriented Programming__ (AOP）。

<!--more-->

<br/>

#### 面向切面编程


> 通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。

在 Objective-C 的世界里，这意味着使用运行时的特性来为 切面 增加适合的代码。通过切面增加的行为可以是：

- 在类的特定方法调用前运行特定的代码

- 在类的特定方法调用后运行特定的代码

- 增加代码来替代原来的类的方法的实现
{: .notice}

iOS 可以使用 Pete Steinberger 开发的 <a href= "https://github.com/steipete/Aspects">Aspects</a> 这个库，大致原理是在 runtime 层，封装了 swizzle method 替换或增加一些方法来实现的。

Aspect只有两个API:
{% highlight Objective-C %}
+ (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;
- (id<AspectToken>)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;
{% endhighlight %}

来看一个小 Demo
{% highlight Objective-C %}
[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter
	usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
    NSLog(@"View Controller %@ will appear animated: %tu", aspectInfo.instance, animated);
} error:NULL];
{% endhighlight %}


这样在 UIViewController 的 viewWillAppear 被调用后，还会再调一下我们定义的 Block，这段日志就会被输出。而打点正好符合这种场景：正事干完之后，额外干一些跟业务无关的事情。

上面的例子，我们通过 AOP 来做的话，大概就是这样
{% highlight Objective-C %}
// DetailViewController.m
- (void)onBuyButtonTapped:(UIButton *)button
{
    // do some stuff, maybe send a request to server
    // no need to call [XXXAnalytics event:]
}

// AppDelegate+Logging.m
- (void)setupAnalytics
{
    [DetailViewController aspect_hookSelector:@selector(onBuyButtonTapped:) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        [XXXAnalytics event:kSomeEventYouDefined];
    } error:NULL];
}
{% endhighlight %}
这样统计代码就从业务代码中剥离出来了。但是又产生了一个新问题，多个 Button Event，岂不是要写很多行这样的代码，「重复」这样的事情，作为一个程序员怎么能忍，简单，造一个方法
{% highlight Objective-C %}
- (void)trackEventWithClass:(Class)klass selector:(SEL)selector event:(NSString *)event
{
    [klass aspect_hookSelector:@selector(selector) withOptions:AspectPositionAfter
    usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        [XXXAnalytics event:event];
    } error:NULL];
}{% endhighlight %}

看起来又干净了些。这时，产品经理又提了个需求：当这个按钮点击时，如果已经登录了，发送 EventA，如果没有登录则发送 EventB，也就是说，不再只是 `[XXXAnalytics event]` 这么简单了，还需要加上额外的逻辑，这也难不倒我们，加上一个 block 即可。
{% highlight Objective-C %}
- (void)trackEventWithClass:(Class)klass
                   selector:(SEL)selector
               eventHandler:(void (^)(id<AspectInfo> aspectInfo))eventHandler
{
    [klass aspect_hookSelector:@selector(selector) withOptions:AspectPositionAfter
    usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        if (eventHandler) {
            eventHandler(aspectInfo);
        }
    } error:NULL];
}
// 使用
[self trackEventWithClass:DetailViewController selector:@seletor(onBuyButtonTapped:) eventHandler:^(id<AspectInfo> aspectInfo){
    user.loggedIn ? [XXXAnalytics event:EventA] : [XXXAnalytics event:EventB];
}];
{% endhighlight %}

不过，不同的buttonEvent在不同的类中方法名未必一致，而且我们也不能保证别人的代码里方法名是如何写的。所以我们最好定义一个config dictionary。标准的做法如下：
{% highlight Objective-C %}
- (void)setupLogging {
    NSDictionary *config = @{
                 @"BXLContactActionCell": @{
                         @"BXLLoggingPageImpression": @"Contact Action - Contact",
                         @"BXLLoggingTrackedEvents": @[
                                 @{
                                     @"BXLLoggingEventName": @"Phone Call",
                                     @"BXLLoggingEventSelectorName": @"dialPressed:",
                                     @"BXLLoggingEventHandlerBlock": ^(id<AspectInfo> aspectInfo) {
                                         [MobClick event:EVENT_PHONE];
                                     },
                                 },
                                 @{
                                     @"BXLLoggingEventName": @"Email Send",
                                     @"BXLLoggingEventSelectorName": @"emailPressed:",
                                     @"BXLLoggingEventHandlerBlock": ^(id<AspectInfo> aspectInfo) {
                                         [MobClick event:EVENT_EMAIL];
                                     },
                                 }
                             ],
                         },
                 @"BXLUserSettingViewController": ....
                 ....
    };
}
{% endhighlight %}

最好的当然还是把以上代码配置在服务器上，这样我们不需要发版本也能够动态改变已有的记录。而且也不容易漏记，解放客户端劳动力，每次去后台读取即可。

<hr>

故事写到这里似乎已经圆满了，产品经理也得到了他所要的动态性和数据。然而我们是精益求精的程序员呀，他们可是永不满足的PM呀。脑洞一开，有没有一种更加直观的验证方式，当产品经理打开App以后，开启某个开关就能看到所有会发送Event的按钮。就像下面这样：

![image]({{ site.url }}/img/aspect.jpg)　　这件事情分为两部分：一部分是显示已配置的区域，另一部分是可视化设置。

<font color="blue"> <strong>是不是有点眼熟，加上动态添加的动画效果的话，活脱脱就是一个mixpannel!</strong> </font>

此时，我们想得更远。如果这一切可以变成一个框架，不需要我们自己手写代码，而是产品、运营对着屏幕自己配置。那该有多好呀！mixpannel是在网页端配置，我们可以直接在手机上配置。比如现在应用内打开一个特殊的debug模式，这样产品就开启了一个新天地：点击你要的button track。实现这个的思路是：

* 获取当前页面的整个View结构，将这一帧渲染在网页端 （省略）
* 长按某一个button, 记录当前UIControl所在路径
* 发送json格式到服务器配置页

![image]({{ site.url }}/img/aspect2.jpg)

<hr>

#### mixpannel
<strong> 原理</strong>

* 用Method Swizzling替换了 UIControl的didMoveToWindow和didMoveToSuperView
* 在这两个方法里加了hook,让UIControl多了额外的target(Java里叫listener)
* 在target中，一旦监听到对应的事件发生，把定义好的事件收集起来

<strong> 局限</strong>

* 只能记录UIContol及其子类中特定方法的事件。




<!-- <strong>显示已配置区域：</strong> 

<strong>可视化设置：</strong> -->










