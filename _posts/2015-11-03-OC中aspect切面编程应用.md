---
layout: post
title:  "OC中aspect切面编程"
modified:   2015-11-03 15:07:19
tags: [ios, 技术]
comments: true
---
每一个技术变化都要从PM的一个需求讲起。对于一个ios应用来说，当第一版的功能完成得差不多以后，我们就必不可少地要为应用中用户的各种行为记录log或track。市面上有不少的应用统计第三方库，类似：umeng,GA,mixpannel & etc.. 假设产品有这么个需求，当用户在详情页点击购买按钮时，记录一下事件。我们实现起来大概会是这样的：

{% highlight: Objective-C %}
// DetailViewController.m

- (void)onBuyButtonPressed:(UIButton *)button
{
    // do some stuff, maybe send a request to server
    [XXXAnalytics event:kSomeEventYouDefined];
} {% endhighlight %}

这个需求就这样轻松搞定了。可是PM又说：我要的不止是点击购买按钮，我还需要点击拨打电话按钮，发送短信按钮，私聊按钮，发布按钮，设置按钮，求购按钮……

一开始，你或许会尝试在PM所说的每一个buttonPress方法中加上[XXXAnalytics event:kSomeEventYouDefined];这行代码。这时候一部分优秀的程序员已经开始抓狂了，因为到处散落着相似的代码。另一部分或许会有些不安，但还是勉强接受了这种写法。

突然有一天，PM一拍脑袋说：我们这个设计已经落伍了，这个版本我们要给所有的UI换上新衣服。另外，以前记的许多log不需要了，增加了新的log。
苦逼的程序员这下崩溃了。他发现不仅要在新的UI中加入track，还需要找到并删除旧的track。然而旧的track散落在程序的各个角落，他不得不ctrl+F一个个搜到再看下是否有用。这种情况下，漏删与少加很可能发生。

为什么会产生这样的情况，还是最初的设计出了问题。如果一开始我们能找到一种合适的架构，使得这些log在同一处被记上，就不会发生这样的情况。此时我们引入Aspect Oriented Programming (AOP）。

面向切面编程
> 通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。

在 Objective-C 的世界里，这意味着使用运行时的特性来为 切面 增加适合的代码。通过切面增加的行为可以是：

- 在类的特定方法调用前运行特定的代码

- 在类的特定方法调用后运行特定的代码

- 增加代码来替代原来的类的方法的实现
{: .notice}

iOS 可以使用 Pete Steinberger 开发的 Aspects 这个库，大致原理是在 runtime 层，通过 swizzle method 来实现的。

来看一个小 Demo
{% highlight: Objective-C %}
[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
    NSLog(@"View Controller %@ will appear animated: %tu", aspectInfo.instance, animated);
} error:NULL];
{% endhighlight %}


这样在 UIViewController 的 viewWillAppear: 被调用后，还会再调一下我们定义的 Block，这段日志就会被输出。而打点正好符合这种场景：正事干完之后，额外干一些跟业务无关的事情。

上面的例子，我们通过 AOP 来做的话，大概就是这样
{% highlight: Objective-C %}
// DetailViewController.m
- (void)onBuyButtonTapped:(UIButton *)button
{
    // do some stuff, maybe send a request to server
    // no need to call [XXXAnalytics event:]
}

// AppDelegate+Logging.m
- (void)setupAnalytics
{
    [DetailViewController aspect_hookSelector:@selector(onBuyButtonTapped:) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        [XXXAnalytics event:kSomeEventYouDefined];
    } error:NULL];
}
{% endhighlight %}
这样统计代码就从业务代码中剥离出来了。但是又产生了一个新问题，多个 Button Event，岂不是要写很多行这样的代码，「重复」这样的事情，作为一个程序员怎么能忍，简单，造一个方法
{% highlight: Objective-C %}
- (void)trackEventWithClass:(Class)klass selector:(SEL)selector event:(NSString *)event
{
    [klass aspect_hookSelector:@selector(selector) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        [XXXAnalytics event:event];
    } error:NULL];
}{% endhighlight %}

看起来又干净了些。这时，产品经理又提了个需求：当这个按钮点击时，如果已经登录了，发送 EventA，如果没有登录则发送 EventB，也就是说，不再只是 [XXXAnalytics event:] 这么简单了，还需要加上额外的逻辑，这也难不倒我们，加上一个 block 即可。
{% highlight: Objective-C %}
- (void)trackEventWithClass:(Class)klass
                   selector:(SEL)selector
               eventHandler:(void (^)(id<AspectInfo> aspectInfo))eventHandler
{
    [klass aspect_hookSelector:@selector(selector) withOptions:AspectPositionAfter usingBlock:^(id<AspectInfo> aspectInfo, BOOL animated) {
        if (eventHandler) {
            eventHandler(aspectInfo);
        }
    } error:NULL];
}

// 使用
[self trackEventWithClass:DetailViewController selector:@seletor(onBuyButtonTapped:) eventHandler:^(id<AspectInfo> aspectInfo){
    user.loggedIn ? [XXXAnalytics event:EventA] : [XXXAnalytics event:EventB];
}];
{% endhighlight %}